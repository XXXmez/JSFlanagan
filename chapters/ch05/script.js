const main = document.querySelector('.main');

function addContent (name, text) {
    main.innerHTML += `
        <div class="content">
            <div class="contentText">
                <span class="nameContent">${name}</span>
                <span class="textContent">${text}</span>
            </div>
        </div>
    `
}
class AddItemContent {
    constructor(title, text, ...rest) {
        this.title = title;
        this.text = text;
        this.outer = rest;
    }
    
    render() {
        main.innerHTML += `
            <div class="content">
                <div class="contentText">
                    <span class="nameContent">${this.title}</span>
                    <span class="textContent">${this.text}</span>
                </div>
            </div>
        `
        console.log(this.title, this.text, this.outer);
    }
}

//new AddItemContent('Первый', 'второй', 'третий', 'четвертый', 'пятый').render();

// 5. Операторы
    // Условные операторы
        // if и switch вынуждают интерпретатор JavaScript выполнять 
        // или пропускать операторы в зависимости от значения выражения.
        addContent('Условные операторы', 'if и switch');
    // Операторы циклов
        // while и for, которые обеспечивают многократное
        // выполнение других операторов
        addContent('Операторы циклов', 'while и for');
    // Операторы переходов
        // break, return и throw, которые заставляют интерпретатор
        // переходить к другой части программы
        addContent('Операторы переходов', 'break, return и throw');


    // 5.1. Операторы-выражения
        // Одной из основных категорий операторов-выражений считаются операторы присваивания
            // greeting = "Hello " + name;
            // i *= 3;

        // Операции инкремента и декремента, ++ и —, относятся к операторам-выражениям
            // counter++;

        // операции d e l e t e связан с удалением свойства объекта
            // delete о.х;

        // Вызовы функций — еще одна основная категория операторов-выражений
            // console.log(debugMessage);
            // displaySpinner ();

    
    // 5.2. Составные и пустые операторы
        // Операторный блок — это просто последовательность операторов, помещенная внутрь фигурных скобок.
            {
                let x = Math.PI;
                let cx = Math.cos(x);
            }


    // 5.3. Условные операторы
        // Такие операторы представляют собой “ветвления”

        //  5.3.1. if
            // Оператор if имеет две формы  
                // Первая
                    if (true) console.log(true);
                    if (1===1) {console.log(1);}
                // Вторая
                    if (1) {
                        console.log(1);
                    } else {
                        console.log(0);
                    }
            // if можно использовать как с {} так и без них, они нужны для лучшего понимания а else принадлежит ближайшему if
                    if (0)
                        console.log(1);
                    else
                        console.log(0);

        // 5.3.2. else if
            // Является часто используемой программной идиомой которая возникает при
            // многократном применении операторов if/else

            if (1) {
                console.log(1);
            } else if (2) {
                console.log(2);
            } else if (3) {
                console.log();
            } else {
                console.log(0);
            }
            // неудобный аналог
            if (1) {
                console.log(1);
            } else {
                if (2) {
                    console.log(2);
                } else {
                    if (3) {
                        console.log(3);
                    } else {
                        console.log(0);
                    }
                }
            }
        
        // 5.3.3. switch
            // switch (выражение) {
            //     операторы
            // }

            switch (1) {
                case 1:
                    console.log(1);
                    break;
                case 2:
                    console.log(2);
                    break;
                case 3: 
                    console.log(3);
                    break;
                default:
                    console.log(0);
                    break;
            }


    // 5.4. Циклы
        // имеется пять операторов цикла: while, do/while,
        // for, for/of (и его разновидность for/await) и for/in.

        // 5.4.1. while
            // while представляет базовый цикл JavaScript
                //w h ile (выражение)
                    //оператор

            let count1 = 0;
            while (count1 < 5) {
                console.log(count1);
                count1++;
            }

        // 5.4.2. do/while
            // похож на while выражение цикла проверяется в конце цикла, а не в начале
                let count2 = 0;
                do {
                    console.log(count2);
                } while (count2++ < 5)

        // 5.4.3. for 
            // for (инициализация; проверка; инкрементирование)
            // оператор

            // эквивалентный for цикл while 
                // инициализация;
                // while(проверка) {
                //  оператор
                //  инкрементирование;
                // }

            for(let count = 0; count < 5; count++) {        // аналог цикла while со 152 строки
                console.log(count);
            }

            let i, j, sum = 0;
            for (i = 0, j = 10 ; i < 10 ; i++, j-- ) {
                sum += i * j;
            }

            // for используется для обхода структуры данных типа связного списка и возвращения последнего объекта в списке
            function tail(о) { // Возвращает хвост связного списка о
                for(; о.next; о = о.next) /* пустое тело */ ; // Обход, пока свойство о.next истинное
                return о;
            }
            console.log(tail(5));

        // 5.4.4. for/of
            // представляет собой совершенно другой вид цикла в
            // сравнении с обыкновенным циклом for

            // работает с итерируемыми объектами
            // массивы, строки, множества и отображения являются итерируемыми

            // сумма всех чисел массива с использованием for/of
                let arrNumbers = [1,5,4,6,7,3,7,8,2], 
                    sum2 = 0;
                for (let number of arrNumbers) {
                    sum2 += number;
                }
                console.log(sum2);

            // Итерация по массивам производится “вживую” — изменения, внесенные во
            // время итерации, могут влиять на ее исход
            
            // for/of с объектами
                // Объекты (по умолчанию) не являются итерируемыми.
                // let o = { х: 1, у: 2, z: 3 };
                // for (let element of o) { // Генерируется ТуреЕггог, потому что o не итерируемый объект
                //     console.log(element);
                // }
            
            // для объекта использовать for/in
            // или for/of с методом Object.keys ():
                let o = { х: 1, у: 2, z: 3 };
                let keys = '';
                for(let k of Object.keys(o)) { // Object.keys() возвращает массив имен свойств для объекта
                    keys += k;
                }
                console.log(keys);
                console.log(Object.keys(o));

            // Если не нужныключи а значения то Object.values()
                let o1 = { х: 1, у: 2, z: 3 };
                let keys1 = 0;
                for(let k1 of Object.values(o1)) { // Object.values() возвращает массив значений свойств для объекта
                    keys1 += k1;
                }
                console.log(keys1);
                console.log(Object.values(o1));

            // если нужны и ключи, и значения свойств объекта, то можно применить
            // цикл for/of с методом O b je c t . e n t r i e s ()
                let pairs = '';
                for(let [k2,v2] of Object.entries(o)) {     // Object.entries() представляет пару “ключ/значение” для одного свойства
                    pairs += k2 + v2;
                }
                console.log(pairs);
                console.log(Object.entries(o1));

            // for/of со строками
                // Строки в ES6 итерируемы по символам
                    let fr ={};
                    for (let lt of 'hehllo') {
                        if (fr[lt]) {
                            fr[lt]++;
                        } else {
                            fr[lt] = 1;
                        }
                    }
                    console.log(fr);
                // Обратите внимание, что итерация в строках производится по кодовым точкам
                // Unicode, а не по символам UTF-16

            // for/of с классами Set и Мар
                // Встроенные классы Set и Мар в ES6 являются итерируемыми
                // При итерации по Set с помощью for/of тело цикла выполняется однократно для каждого элемента множества.
                    // вывода уникальных слов из строки текста
                    let text = "Na na na na na na na na Batman!";
                    let wordSet = new Set(text.split(" "));
                    let unique = [];
                    for (let word of wordSet) {
                        unique.push(word);
                    }
                    console.log(unique);
                
                // итерация объекта Мар происходит по парам “ключ/значение”
                    let m = new Map([[1,'map']]);
                    for(let [key3, value3] of m) {
                        console.log(key3, value3);
                    }

                // Асинхронная итерация с помощью for/await
                    // В ES2018 вводится новый вид итератора, называемый асинхронным итератором
                    // и разновидность цикла for/of, известная как цикл for/await,
                    // который работает с асинхронными итераторами
                        // просто пример изучение позднее
                            // Читать порции из асинхронно итерируемого потока данных и выводить их
                            async function printStream(stream) {
                                for await (let c of stream) {
                                    console.log(c);
                                }
                            }

        
        // 5.4.5. for/in
            // цикл for/of требует итерируемого объекта после of    появилсяв ES6
            // цикл for/in работает с любым объектом после in       for/in с самого начала
                // for (переменная in объект)
                //     оператор

            for (let p in o) {
                console.log(o[p]);
            }

            // Чтобы выполнить оператор for/in , интерпретатор JavaScript сначала вычисляет
            // выражение объект.

                let o45 = { х: 1, у: 2, z: 3 }, a45 = [], i45 = 0;
                for (a45[i45++] in o45) ;
                console.log(o45);
                console.log(a45);

            // Массивы JavaScript — просто специализированный вид объектов
            // индексы массива представляют собой свойства, которые можно перечислять с помощью цикла for/in

            // Например, следующая строка, дополняющая предыдущий код, перечисляет индексы массива 0, 1 и 2
                for (let i in a45) console.log(i);

            // Частые не очевидные ошибки могут быть из за использования цикла for/in с массивами
            // когда нужен был for/of. с массивами всегда нужен for/of

            // Цикл for/in в действительности не перечисляет все свойства объекта
            // не перечисляет свойства, именами которых являются значения Symbol
            

    // 5.5. Переходы
        // Как вытекает из их названия, они заставляют интерпретатор JavaScript переходить
        // в новое место внутри исходного кода

        // break вынуждает интерпретатор перейти в конец цикла или другого оператора
        // continue заставляет интерпретатор пропустить остаток тела цикла и перейти в начало
            // цикла, чтобы начать новую итерацию
        // return вынуждает интерпретатор выйти из вызова функции обратно в код,
            // который ее вызвал, и также предоставляет значение для вызова
        // throw является своего рода промежуточным возвратом из генераторной функции
            // инициирует исключение и предназначен для работы с оператором try/catch/finally
        
        // 5.5.1. Помеченные операторы
            // Любой оператор может быть помечен путем его предварения идентификатором и двоеточием
                //  идентификатор: опера тор

            // Помечая оператор, вы даете ему имя, которое можно использовать для ссылки
                // на него из какого-то другого места в программе

            // За счет предоставления циклу имени вы можете
                // применять внутри его тела операторы break и continue для выхода из цикла
                // или перехода прямо в начало цикла, чтобы начать новую итерацию

            // Ниже показан пример помеченного цикла w h ile и
                // оператора continue , который задействует метку:

                // metca: while(1 !== null) {
                //     //
                //     console.log(1);
                //     continue metca;     // перейти к метке
                //     //
                // }
        
        // 5.5.2. break
            // break, используемый в одиночку, обеспечивает немедленное завершение
                // самого внутреннего включающего оператора цикла или switch
            // Синтаксис - break;

                // for(let i = 0; i < a.length; i++) {
                //     if (a[i] === target) break;
                // }

            // JavaScript также разрешает дополнять ключевое слово b re ak меткой оператора
                // (просто идентификатором без двоеточия):
                // break имя__метки;

        // 5.5.3. continue
            // Оператор continue похож на break. Тем не менее, вместо выхода из цикла
                // continue перезапускает цикл со следующей итерации
            // Синтаксис - continue;

            // с меткой 
                // continue имя_метки;
            
            // оператор continue может использоваться только внутри тела цикла

            // Для разных видов циклов это означает разные вещи
                // В цикле while указанное в операторе цикла выражение проверяется снова,
                    // и если оно истинно, тогда тело цикла выполняется с самого начала
                // В цикле do/while управление переходит в конец цикла, где снова проверяется
                    // условие цикла, прежде чем начинать цикл с начала
                // В цикле for вычисляется выражение инкрементирование и затем снова
                    // проверяется выражение проверка, чтобы выяснить, должна ли выполняться
                    // еще одна итерация
                // В цикле for/of или for/in цикл начинается заново со следующего итерируемого
                    // значения или следующего имени свойства, присваиваемого указанной
                    // переменной

        // 5.5.4. return
            // return внутри функции указывает значение вызовов этой функции

            // Синтаксис - return выражение;

            // Оператор return может встречаться только внутри тела функции

            // function square (х) { return х*х; }      // => вернет x в квадрате

        // 5.5.5. yield
            // yield во многом похож на return но используется только в генераторных функциях ES6

            // Генераторная функция, которая выдает диапазон целых чисел
                // function* range(from, to) {
                //     for (let i = from; i <= to; i++) {
                //         yield i;
                //     }
                // }
            
            // Чтобы понять yield , нужно освоить итераторы и генераторы
                // более глубокое изучение будет позже
        
        // 5.5.6. throw
            // синтаксис - throw выражение;
            
            // пример функции, которая генерирует объект Error в случае вызова с недопустимым аргументом

            function factorial (n) {
                if (n < 0) throw new Error('Значение не должно быть отрицательным');
                let f56;
                for (f56 = 1; n > 1; f56 *= n, n--) ;
                return f56;
            }
            console.log('throw факториал: ', factorial(5));

        // 5.5.7. try/catch/finally
            // try/catch/finally является механизмом обработки исключений JavaScript

            // В конструкции try данного оператора просто определяется блок кода, чьи исключения должны быть обработаны

            // За блоком try следует конструкция catch , которая представляет собой блок операторов, вызываемый при
                // возникновении исключения где-нибудь внутри блока try.

            // После конструкции catch находится блок finally , содержащий код очистки, который гарантированно
                // выполнится вне зависимости от того, что произошло в блоке try.

            // После конструкции catch находится блок finally, содержащий код очистки, который гарантированно
                // выполнится вне зависимости от того, что произошло в блоке try .

            // try/catch/finally - начинаются и заканчиваются фигурными скобками

            let e57 = 1;

            try {
                console.log('try: ', 1);
                // В нормальной ситуации этот код выполняется от начала до конца блока
                // безо всяких проблем. Но иногда он может генерировать исключение,
                // либо напрямую с помощью оператора throw, либо косвенно за счет вызова
                // метода, который генерирует исключение.
            }
            catch (e57) {
                console.log('catch: ', 2);
                // Операторы в данном блоке выполняются, если и только если в блоке try
                // было сгенерировано исключение. Эти операторы могут использовать
                // локальную переменную е для ссылки на объект Error или другое значение,
                // которое было указано в throw. В блоке можно каким-то образом
                // обработать исключение, проигнорировать его, ничего не делая,
                // или повторно сгенерировать исключение с помощью throw.
            }
            finally {
                console.log('finally: ', 3);
                // Данный блок содержит операторы, которые всегда выполняются
                // независимо от того, что произошло в блоке try.
                // Они выполняются при завершении блока try:
                // 1) нормальным образом после того, как достигнут конец блока;
                // 2) из-за оператора break, continue или return;
                // 3) из-за исключения, которое было обработано конструкцией catch выше;
                // 4) из-за необработанного исключения, которое продолжило
                // свое распространение.
            }
            
            // Обратите внимание, что обычно за ключевым словом c a tc h следует идентификатор
                // в круглых скобках, который подобен параметру функции
            
            // пример оператора try/catch c методом factorial()

            try {
                // let n57 = Number(prompt('Введите положительное число', ''));
                let n57 = 5;

                let f57 = factorial(n57);

                console.log(n57 + ' != ' + f57);
            }

            catch(ex57) {
                console.log('Ошибка: ', ex57);
            }
    
    // 5.6. Смешанные операторы
        // В этом разделе описаны три оставшихся оператора with, debugger и "use strict".

        // 5.6.1. with
            // синтаксис
            // with (объект)
            //     оператор

            // Этот оператор создает временную область видимости со свойствами объектами

            // Оператор with запрещен в строгом режиме
            // воспринимается как нерекомендуемый в нестрогом режиме
            // избегайте его применения.

        // 5.6.2. debugger
            // Оператор debugger обычно ничего не делает

            // альтернатива в браузере это точка остановка в консоли разработчика

            // синтаксис
            // function f (о) {
            //     if (о === undefined) debugger;  //Временная строка для отладочных целей
            //                                     //Далее идет остальной код функции
            // }

        // 5.6.3. "use strict"
            // "use strict” — это директива, появившаяся в ES5.
            // Директивы не являются операторами. Существуют два важных отличия между директивой "use strict" и обыкновенными операторами.
                // Она не содержит любые ключевые слова языка: директива представляет собой просто оператор выражения, состоящий из специального строкового
                // литерала (в одинарных или двойных кавычках)
                
                // Она может находиться только в начале сценария или тела функции до появления каких-либо подлинных операторов
            
            // Директива "use strict" предназначена для указания, что код после нее будет строгим кодом

            // В строгос режиме устранены важные языковые недостатки,
            // а также обеспечены более строгая проверка ошибок и увеличенная безопасность
    
    
    // 5.7. Объявления
        // пропуск - практика
            {
                let typeNumber = 1;
                let typeString = '1';
                let typeObject = {1:1, 2:2};
                let typeArray = [1,2];
                let typeTrue = true;
                let typeNaN = NaN;
                let typeUndefined = undefined;
                let typeNull = null;
                let typeFunction = function () {
                    let x = 1+1;
                };
                let typeInfinity = Infinity;
                let typeBigInt = BigInt(1997);
                console.log("Тип число:     ", typeof typeNumber);
                console.log("Тип NaN:       ", typeof typeNaN);
                console.log("Тип infinity:  ", typeof typeInfinity);
                console.log("Тип строка:    ", typeof typeString);
                console.log("Тип объект:    ", typeof typeObject);
                console.log("Тип массив:    ", typeof typeArray);
                console.log("Тип Null:      ", typeof typeNull);
                console.log("Тип true:      ", typeof typeTrue);
                console.log("Тип undefined: ", typeof typeUndefined);
                console.log("Тип функция:   ", typeof typeFunction);
                console.log("Тип BigInt:    ", typeof typeBigInt);

                const arr = [];
                const arr1 = [];
                const obj = [];
                const obj1 = [];

                console.log("массив ==  : ", arr == arr1);
                console.log("массив === : ", arr == arr1);
                console.log("объект ==  : ", obj == obj1);
                console.log("объект === : ", obj == obj1);
            }
        // конец
    
    // 5.7. Объявления
        // Это определние новых значений и назначения им имен
        // const, let, var, function, class, import и export
        
        // 5.7.1. const, let и var
            // const объявляет константы
            // let — переменные
            // var — переменные старого типа

            const quPI = 2 * Math.PI;
            let radius = 3;
            var cf = quPI * radius;

        // 5.7.2. function
            // function применяется для определения функций
            function areap(radius) {
                return Math.PI * radius;
            }
            // Объявление функции создает объект функции и присваивает его указанному имени — areap в приведенном примере

            // Существуют функции генераторы, объявляются как function*, так же есть асинхронные функции пишутся async function

        // 5.7.3. class
            // class добавили в ES6
            // пример
                class Circle {
                    constructor (radius) { this.r = radius;}
                    area () {return Math.PI * this.r}
                }
            
            // классы не поднимаются по этому класс нельзя испольозвать в коде до его объявления

        // 5.7.4. import и export
            // применяются для того что бы значения из одного модуля JS использовать в другом модуле JS
            // Модуль это файл (script.js) имеет своё пространство имен
            
            // import применяются для импортирования и назначения им имен из другого модуля в текущий 
                // import Circle from './geometry/circle.js';
                // import { PI, TAU } from "./geometry/constants. js";
                // import { magnitude as hypotenuse } from "./vectors/utils. js";

            // Значения в модуле являются закрытыми и не могу сами импортироваться если они не экспортированны
            // export указывает какие значения будут экспортированны
                // const PI74 = Math.PI;
                // const TAU74 = 2 * PI;
                // export { PI74, TAU74 };