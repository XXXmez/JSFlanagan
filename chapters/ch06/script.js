const main = document.querySelector('.main');

function addContent (name, text) {
    main.innerHTML += `
        <div class="content">
            <div class="contentText">
                <span class="nameContent">${name}</span>
                <span class="textContent">${text}</span>
            </div>
        </div>
    `
}
class AddItemContent {
    constructor(title, text, ...rest) {
        this.title = title;
        this.text = text;
        this.outer = rest;
    }
    
    render() {
        main.innerHTML += `
            <div class="content">
                <div class="contentText">
                    <span class="nameContent">${this.title}</span>
                    <span class="textContent">${this.text}</span>
                </div>
            </div>
        `
        console.log(this.title, this.text, this.outer);
    }
}
//new AddItemContent('Первый', 'второй', 'третий', 'четвертый', 'пятый').render();

addContent('Условные операторы', 'if и switch');

// 6.1. Введение в объекты
    // Объект — это составное значение
    // он агрегирует множество значений (элементарные значения или другие объекты)
    // позволяет хранить и извлекать внутренние значения по имени

    // объект это неупорядоченная колекция свойств
    
    // В JavaScript любое значение, отличающееся от строки, числа, значения
        // Symbol, true, false, null или undefined -- является объектом
    
    // В дополнение к имени и значению каждое свойство имеет три атрибута свойства
        // атрибут writable (допускает запись) указывает, можно ли устанавливать значение свойства
        // атрибут enumerable (допускает перечисление) указывает, возвращается ли имя свойства в цикле for/in ;
        // атрибут configurable (допускает конфигурирование) указывает, можно ли удалять свойство и изменять его атрибуты;

    // По умолчанию все свойства созданные пользователем, докускают запись/перечисление/конфигурирование


// 6.2. Создание объектов
    // объект можно создать
        // объектные литералы {}
        // ключевого слова new
        // функции Object.create()
    
    // 6.2.1. Объектные литералы
        // такой способ самый легкий

        // представляет собой разделенный запятыми список пар имя:значение, заключенный в фигурные скобки

        // Имя свойства — это идентификатор JavaScript или строка (допускается и пустая строка).
        // Значение свойства — это любое выражение JavaScript; значение выражения 
            // (оно может быть элементарным или объектным значением) становится значением свойства
        
        // Примеры
        let obj1 = {};                          // объект без свойств
        let obj2 = {x: 0, y: 1};                // два свойства числовые
        let obj3 = {x: obj2.x, y: obj2 + 1};    // более сложное значение
        let obj4user = {                        // имена этих свойств включают пробелы и дефисы, так как для них используются строковые литералы
            'name man': 'Ruslan',               
            'age-man': 24,
            'heman': true,
            'parents': {
                'mom': 'Luda',
                'dad': 'Lesha'
            },
        };

        // За последний свойством можно оставлять хвостик ошибки от этого не будет

    // 6.2.2. Создание объектов с помощью операции new
        // Операция new создает и инициализирует новый объект.
        // за ключевым словом new должен следовать вызов функции

        // Подобная функция называется конструктором и предназначена для инициализации вновь созданного объекта

        // Так же предусмотрены конструкторы для встроенных типов, например:
            let o1 = new Object();      // Создает пустой объект: то же, что и {}
            let a1 = new Array();       // Создает пустой массив: то же, что и []
            let d1 = new Date();        // Создает объект Date, представляющий текущее время
            let m1 = new Map();         // Создает объект Мар для отображения ключ/значение

    // 6.2.3. Прототипы
        // Почти с каждым объектом JavaScript ассоциирован второй объект JavaScript,
        // который называется прототипом, и первый объект наследует свойства от прототипа

        // объекты, создаваемые объектными литералами, имеют тот же самый
        // объект-прототип, на который можно ссылаться в коде JavaScript как на
        // Object.prototype

        // Объекты, создаваемые с использованием ключевого слова
        // new и вызова конструктора, применяют в качестве своих прототипов значение
        // свойства prototype функции конструктора

        // объект, созданный посредством new Object(), наследует Object.prototype, как и объект, созданный с помощью {}

        let ob1 = {};
        let ob2 = new Object();
        let ob3 = Object.create(null)

        console.log("ob1 : ", ob1);
        console.log("ob2 : ", ob2);
        console.log("ob3 : ", ob3);

        // цепочкой прототипов это 
        // Date.prototype наследует свойства от Object.prototype, 
        // поэтому объект Date, созданный посредством new Date (), наследует свойства от Date.prototype и Object.prototype

    // 6.2.4. Object.create()
        // Object.create() создает новый объект, используя в качестве его прототипа первый аргумент

        let ob4 = Object.create({x: 1, y: 2});
        console.log("ob4 : ", ob4);
        console.log(ob4.x + ob4.y);

        // можете передать null, чтобы создать новый объект, не имеющий прототипа,
        // но в таком случае вновь созданный объект ничего не унаследует
        ob3.x = 4;
        ob3.y = 5;
        console.log("ob3 : ", ob3);   // методов нет

        // а если нужен обычный объект нужно передать
        let ob5 = Object.create(Object.prototype);
        console.log("ob5 : ", ob5);


// 6.3. Запрашивание и установка свойств
    // 6.3.1. Объекты как ассоциативные массивы
        // Объекты JavaScript являются ассоциативными массивами

    // 6.3.2. Наследование
        // Запрашиваем свойство х в объекте о
        // Если в о отсутствует собственное свойство с таким именем, тогда свойство х запрашивается в объекте-прототипе о
        // Если объект-прототип не имеет собственного свойства   по имени х, но сам располагает прототипом, то запрос выполняется для прототипа объекта-прототипа
        // Процесс продолжается до тех пор, пока свойство х не будет найдено или не обнаружится объект с прототипом null

        let perX = {};  // наследует методы объекта от Object .prototype
        perX.x = 3;     // теперь имеет собственное свойство х
        perX.ge = 10;
        let perY = Object.create(perX); // perY наследует свойства от perX и Object.prototype
        perY.y = 4;     // имеет собственное свойство perY.y
        let perZ = Object.create(perY); // и дальше все так же
        perZ.z = 7;
        
        let perA = Object.create(perZ); // и дальше все так же
        perA.a = perA.z + perA.y + perA.x; // наследует свойства
        console.log(perA);  // => 14
        perA.a1 = perA.z + perA.ge      // 17
        perZ.ge = 12;
        perA.a2 = perA.z + perA.ge      // 19, ge взялось из ближайшего прототипа если бы ge не было в perZ его бы взяли из perX
        console.log(perA);


        let un = {r: 1};

        let uc = Object.create(un)
        uc.x = 3, uc.y = 6;
        uc.r = 4;
        console.log(un.r); // 1 его не трогает