const main = document.querySelector('.main');

function addContent (name, text) {
    main.innerHTML += `
        <div class="content">
            <div class="contentText">
                <span class="nameContent">${name}</span>
                <span class="textContent">${text}</span>
            </div>
        </div>
    `
}

// 4.1. Первичные выражения
    // Первичными выражениями в JavaScript являются константы или литеральные значения, 
    // определенные ключевые слова языка и ссылки на переменные
    
    // Литералы — это постоянные значения, встроенные напрямую в программу
        1.23            // числоловой литерал
        'string'        // строковый  литерал
        // /шаблон/     // регулярный литерал

    // Зарезервированные первичными выражениями
        true        // Вычисляется как булевское истинное значение
        false       // Вычисляется как булевское ложное значение
        null        // Вычисляется как нулевое значение
        this        // Вычисляется как "текущий” объект
    
    // третий тип первичных выражений представляет собой ссылку на
    // переменную, константу или свойство глобального объекта:
        // i                // Вычисляется как значение переменной i
        // sum              // Вычисляется как значение переменной sum
        // undefined        // Вычисляется как "неопределенное" свойство глобального объекта

    // ReferenceError - переменной не существует


// 4.2. Инициализаторы объектов и массивов
    // Инициализаторы объектов и массивов — это выражения, значениями которых
    // будут вновь созданные объекты или массивы

    // Инициализатор массива представляет собой разделяемый запятыми список сражений, содержащийся в квадратных скобках
        let array1 = [];                // Пустой массив 
        let array2 = [1+3, 4+3];        // Двухэлементный массив 4 7
        addContent('Инициализация массива', 'let array = [1,2,3];');

    // выражения элементов в инициализаторе мас
    // сами могут быть инициализаторами мас
    // Вложенный массив
        let array3 = [[1],[2,3],[4,5,6]];

    // В литерал массива можно включать неопределенные элементы
        let array4 = [1,,,,5];      // => [1, пусто × 3, 5]
        addContent('Неопределенные элементы в массиве', 'let array = [1,,,,5];');

    // В инициализаторе массива разрешена хвостовая запятая, неопеделенного массива не будет
        let array5 = [1,2,3,];      // => [1, 2, 3]
    
    // Инициализатор объектов похоже на массивы
    // квадратные скобки [] меняются на фигурные {}
    // каждое подвыражение снабжается префиксом с именем свойства и двоеточием
        let object1 = {};
        let object2 = {x:1, y:2, z:3};
        addContent('Инициализация объекта', 'let object = {x:1, y:2, z:3};');

    // Вложенные объектные литералы
        let object3 = {
            obj1: {x: 1, y: 2},
            obj2: {x: 3, y: 4}
        };

// 4.3. Выражения определений функций
    let square = function (x) { return x * x };         // квадрат  числа
    addContent('Выражения определений функций', 'let square = function (x) { return x * x };');
    
// 4.4. Выражения доступа к свойствам
    // Есть два вида синтаксиса для доступа к свойствам 
    // выражение . идентификатор
    // выражение [ выражение ]

    let object4 = {x:1, y: {z:2, c: 3}, 'xy xy': 'пробел'};
    let array6 = [object4 , 1,[2,3]];

    console.log(object4.x);
    console.log(object4.y.z);
    console.log(object4['x']);
    console.log(object4['xy xy']);
    
    console.log(array6[1]);
    console.log(array6[2]['1']);
    console.log(array6[0].y);

    addContent('Выражения доступа к свойствам', 'array6[2][\'1\'];');

    // 4.4.1. Условный доступ к свойствам
        // В ES2020 появились два новых вида выражений доступа к свойствам:
        // выражение ?. идентификатор
        // выражение ?. [ выражение ]

        let a = {b:{c: 5}};

        console.log(a.b);
        console.log(a?.b);
        console.log(a.b.c.d);           // Если без условного доступа то это конец
        console.log(a.b.c?.d?.a);       // Если использовать ?. тогда можно проверять на сколько хочешь глубоко ошибки не будет только undefined


// 4.5. Выражения вызова
    // Выражение вызова — это синтаксис JavaScript для вызова (либо выполнения) функции или метода
    function f1 (e) {return (e)};
    console.log(f1(0));                  //  f1 - выражение функции; 0 - выражение аргумента
    console.log(Math.max(1,2,3));        //  Math.max - - выражение функции; 1,2,3 - выражение аргумента
    console.log([3,1,2].sort());         //  sort() - выражение функции; [3,1,2] - выражение аргумента

    // 4.5.1. Условный вызов
        // В ES2020 функцию можно вызывать также с применением ?. () вместо ()
    
    addContent('Выражения вызова', 'синтаксис JavaScript для вызова (либо выполнения) функции или метода. Пример : f1(0)');


// 4.6. Выражения создания объектов
    // Выражение создания объекта создает новый объект и вызывает функцию
    // (называемую конструктором) для инициализации свойств этого объекта.
        new Object();
        new Object(2,3);

    // Если аргумента нет то скобки можно опустить
        new Object;

// 4.7. Обзор операций
    // Операции используются в JavaScript для арифметических выражений и т.д.
    
    // 4.7.1. Количество операндов
        // бинарными операциями
            // Большинство операций JavaScript они ожидают два операнда
            // 2 + 2
        // унарных операций
            // превращают одиночное выражение в одиночное более сложное выражение
            // - в выражении -х

    // 4.7.2. Типы операндов и результата
        // Некоторые операции работают со значениями любого типа
        
        // Операции JavaScript обычно по мере надобности преобразуют типы
        // Операция умножения * ожидает числовые операнды
            // "3" * "5" вернет число 15 преобразовав их в числа

    // 4.7.3. Побочные эффекты операций
    
    // 4 7.4. Приоритеты операций
        // у всех операций есть приоретер по выполнению, сначала выполняется та у которой больше приоритет

        // Рассмотрим следующее выражение:
            // w = X + y*z;
            // умножения * имеет более высокий приоритет
            // чем операция сложения + 
            // поэтому умножение выполняется раньше сложения

        // Операция присваивания = имеет самый низкий приоритет

        // Приоритеты операций можно переопределять а счет явного использования круглых скобок
            // w = (х + у) *z;
        
        let g = null
        console.log(g ?? 4);

        // Когда в JavaScript добавляются новые операции, они не всегда естественным
        // образом вписываются в эту схему приоритетов
            // Операция ?? имеющая более низкий приоритет
            // чем | | и && по на самом деле ее приоритет относительно упомянутых 
            // операций не определен, и стандарт ES2020 требует явного использования
            // круглых скобок при смешивании ?? с | | или &&

            // Аналогично новая операция возведения в степень **
            // Пе обладает четко определенным приоритетом относительно унарной операции

    // 4.7.5. Ассоциативность операций
        // У каждой операции есть её ассоциативность
        // которая определяет порядок выполнения операций с одинаковыми приоритетами
        
        // Например, операция вычитания имеет ассоциативность слева направо
            // w = x - у - z
        // то же самое, что и
            // W = ( (х - у) - z)

        // Но операция возведения в степень, унарная операция, операция присваивания
        // и тернарная условная операция имеют ассоциативность справа налево

    // 4.7.6. Порядок вычисления
        // Например, в выражении w = х + у * z
        // подвыражение w вычисляется первым, а за ним х, у и z
        // Далее значения у и z перемножаются
        // произведение складывается со значением х
        // результат присваивается переменной или свойству, указанному выражением w

        // Добавление круглых скобок к выражениям может изменить относительный 
        // порядок выполнения умножения сложения и присваивания
        // НО но не порядок вычисления слева направо
        